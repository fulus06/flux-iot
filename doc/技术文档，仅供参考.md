这份文档基于 **Rust (Core) + WebAssembly (Plugin) + Rhai (Script)** 的技术选型，为您规划 **FLUX IOT 飞流物联网平台** 的详细技术架构与开发指南。仅供参考，可根据`./架构.md`自行修改。

---

# 第一部分：FLUX IOT 技术架构文档

## 1. 架构设计总览

### 1.1 设计理念
*   **轻量级 (Lightweight)**: 编译产物单一二进制文件，极低的内存占用（<50MB 空载），适合边缘网关和云端部署。
*   **高性能 (High Performance)**: 基于 Rust 的 `Tokio` 异步运行时，实现高并发连接（C1000K）与低延迟消息处理。
*   **高扩展 (Extensible)**:
    *   **Wasm**: 实现协议解析与复杂算法的**热插拔**与**沙箱隔离**，避免插件崩溃导致主程序退出。
    *   **Rhai**: 提供安全、零编译的脚本环境，用于用户自定义业务逻辑与规则编排。

### 1.2 系统分层架构

```text
[ 业务应用层 (Application) ]
   | 数据报表 | 场景联动 | 告警中心 | 系统管理 |
--------------------------------------------------
[ 接口网关层 (API Gateway) ]
   | RESTful API (Axum) | WebSocket | GraphQL |
--------------------------------------------------
[ 核心服务层 (Core Services - Rust) ] -> 负责调度、一致性、I/O
   |-- 设备注册中心 (Device Registry)
   |-- 消息总线 (Message Bus / Event Loop)
   |-- 规则引擎宿主 (Rule Engine Host)
   |-- 视频流媒体服务 (Video Stream Server)
   |-- 插件运行时宿主 (Wasm Host Runtime)
   |-- 脚本引擎宿主 (Rhai Engine Host)
--------------------------------------------------
[ 扩展层 (Extension Layer) ]
   |-- Wasm 插件 (Plugins): 协议解析(Modbus/TCP)、算法(加密)
   |-- Rhai 脚本 (Scripts): 规则判断、数据清洗、场景逻辑
--------------------------------------------------
[ 数据存储层 (Data Storage) ]
   |-- 元数据: PostgreSQL / SQLite (边缘端)
   |-- 时序数据: InfluxDB / TDengine
   |-- 缓存: Redis (可选，单机版可用内存Map替代)
```

---

## 2. 核心模块技术选型

| 模块 | 技术栈/Crate | 说明 |
| :--- | :--- | :--- |
| **异步运行时** | `Tokio` | 工业级异步标准，支撑高并发 I/O |
| **Web 框架** | `Axum` 或 `Salvo` | 极其轻量且基于 Tokio 生态 |
| **数据库 ORM** | `Sea-ORM` (Async) | 纯 Rust 编写，解耦数据库类型，支持动态构建查询 |
| **MQTT Broker** | `Rumqttd` (Embed) | 内嵌式 MQTT Broker，无需外部部署 Mosquitto |
| **Wasm 运行时** | `Wasmtime` 或 `Wasmer` | 提供高性能的 JIT 编译和沙箱安全 |
| **脚本引擎** | `Rhai` | 专为 Rust 设计的嵌入式脚本，安全无 Panic |
| **视频流处理** | `GStreamer-rs` / `FFmpeg-next` | Rust 绑定底层库，处理 RTSP 转 WebRTC/HLS |
| **日志/监控** | `Tracing` + `OpenTelemetry` | 分布式链路追踪标准 |

---

## 3. 关键架构流程

### 3.1 设备接入与数据上报流程
1.  **连接**: 设备通过 TCP/MQTT 连接到 Rust 核心监听端口。
2.  **识别**: Rust 核心根据端口映射或报头特征，确定使用的 **Wasm 协议插件**。
3.  **解码 (Wasm)**: Rust 将原始字节流 `Vec<u8>` 传入 Wasm 内存；Wasm 解析后返回标准 JSON 结构体。
4.  **路由**: 消息进入 Rust 内部总线 (Channel)。
5.  **规则 (Rhai)**: 规则引擎提取消息，注入 Rhai 上下文，执行用户定义的过滤脚本。
6.  **存储**: 通过 Sea-ORM 写入时序数据库。

### 3.2 插件热更新架构
*   **加载**: 平台启动或 API 触发时，Rust 读取 `.wasm` 文件。
*   **编译**: 使用 `Wasmtime` 将 Wasm 字节码 JIT 编译为机器码。
*   **实例化**: 为每个插件创建独立的 `Store` 和 `Instance`，确保内存隔离。
*   **替换**: 使用 `RwLock` 替换旧的插件实例句柄，实现无感热更新。

---

# 第二部分：功能开发文档

## 1. 基础服务开发指南 (Rust Core)

### 1.1 目录结构建议
```text
flux-iot-core/
├── src/
│   ├── api/          # HTTP 接口定义
│   ├── core/
│   │   ├── bus.rs    # 内部消息总线
│   │   ├── executor.rs # 插件与脚本调度器
│   │   └── device.rs # 设备状态管理 Actor
│   ├── plugin/       # Wasm 宿主逻辑封装
│   ├── script/       # Rhai 引擎封装
│   ├── stream/       # 视频流媒体服务
│   ├── entity/       # 数据库实体 (Sea-ORM)
│   └── main.rs
├── plugins/          # 默认 Wasm 插件目录
└── config/           # 配置文件
```

### 1.2 核心接口定义 (Trait)
为了统一管理，Rust 侧需要定义标准 Trait 供内部调用：

```rust
// 插件宿主接口
pub trait PluginHost {
    // 调用插件的解码函数
    fn decode(&self, plugin_id: &str, raw_data: &[u8]) -> Result<StandardMessage>;
    // 调用插件的编码函数
    fn encode(&self, plugin_id: &str, json_data: &Value) -> Result<Vec<u8>>;
}

// 脚本执行接口
pub trait ScriptEngine {
    // 执行规则脚本
    fn eval_rule(&self, script: &str, context: &Context) -> bool;
}
```

### 1.3 视频流服务 (Stream Service)
*   **技术**: 使用 Rust 封装 `GStreamer` pipeline。
*   **实现**: 创建一个 `StreamManager` struct。
    *   `input`: RTSP URL (from IP Camera).
    *   `pipeline`: `rtspsrc ! rtph264depay ! h264parse ! flvmux ! rtmpsink` (转 RTMP) 或使用 `webrtcbin` (转 WebRTC)。
    *   **注意**: 视频流进程应独立于业务线程，避免阻塞 API。

---

## 2. 插件开发指南 (Wasm Plugin)

> 适用于：协议解析、加解密、第三方适配。

### 2.1 插件 SDK (Rust Guest)
开发一个 `flux-plugin-sdk` crate 供插件开发者使用。

```rust
// flux-plugin-sdk/src/lib.rs
use serde::{Serialize, Deserialize};

#[derive(Serialize, Deserialize)]
pub struct StandardMessage {
    pub device_id: String,
    pub values: std::collections::HashMap<String, f64>,
}

// 宏定义，简化插件入口
#[macro_export]
macro_rules! export_plugin {
    ($handler:ty) => {
        #[no_mangle]
        pub extern "C" fn decode(ptr: *const u8, len: usize) -> u32 {
            // ... 处理内存指针和序列化逻辑 ...
        }
    };
}
```

### 2.2 示例：Modbus 解析插件
开发者编写如下代码，编译为 `.wasm`：

```rust
use flux_plugin_sdk::{PluginHandler, StandardMessage};

struct ModbusPlugin;

impl PluginHandler for ModbusPlugin {
    fn on_decode(raw: &[u8]) -> StandardMessage {
        // 1. 解析 Modbus 帧头
        let unit_id = raw[0];
        let function_code = raw[1];
        
        // 2. 业务逻辑转换
        let temp_raw = u16::from_be_bytes([raw[3], raw[4]]);
        let temp = temp_raw as f64 / 10.0;

        StandardMessage {
            device_id: format!("sensor_{}", unit_id),
            values: [("temperature".to_string(), temp)].into(),
        }
    }
}

export_plugin!(ModbusPlugin);
```

---

## 3. 动态脚本开发指南 (Rhai Script)

> 适用于：规则引擎、场景联动。

### 3.1 规则引擎脚本
Rust 核心会将设备上报的数据注入到 `msg` 变量中。

```javascript
// 示例：高温告警规则
// 变量 'msg' 和 'env' 由 Rust 注入

let temp = msg.values.temperature;

// 逻辑判断
if temp > 45.0 {
    print("Warning: High temperature detected!");
    
    // 返回 true 触发后续告警动作
    return true; 
} else {
    return false;
}
```

### 3.2 场景联动脚本
Rust 核心提供控制设备的 API 绑定到 Rhai。

```javascript
// 示例：联动控制
// 当光照低于阈值，并且有人移动时

if msg.values.lux < 50 && msg.values.motion == 1 {
    // 调用 Rust 暴露的函数 'send_command'
    // 参数: (device_id, command, params)
    send_command("light_switch_01", "TurnOn", #{ brightness: 100 });
    
    // 记录日志
    log_info("Opened light due to dark environment.");
}
```

---

## 4. 数据库设计 (核心表结构)

建议使用 SQL 迁移文件管理。

### 4.1 产品表 (products)
| 字段 | 类型 | 说明 |
| :--- | :--- | :--- |
| id | UUID | 主键 |
| key | Varchar | 产品标识 (Key) |
| protocol_plugin_id | Varchar | **关联的 Wasm 插件 ID** |
| metadata | JSONB | 物模型定义 (TSL) |

### 4.2 设备表 (devices)
| 字段 | 类型 | 说明 |
| :--- | :--- | :--- |
| id | UUID | 主键 |
| product_id | UUID | 外键 |
| secret | Varchar | 设备密钥 |
| status | Int | 在线/离线 |
| last_online | Timestamp | 最后上线时间 |

### 4.3 规则表 (rules)
| 字段 | 类型 | 说明 |
| :--- | :--- | :--- |
| id | UUID | 主键 |
| trigger_script | Text | **Rhai 触发脚本内容** |
| action_type | Varchar | 动作类型 (Webhook/Command) |

---

## 5. 开发与部署流程

1.  **环境准备**:
    *   安装 Rust (`rustup`).
    *   安装 `wasm-pack` 或添加 `wasm32-unknown-unknown` target。
2.  **构建核心**:
    *   `cargo build --release` -> 生成 `flux-iot-server`。
3.  **构建插件**:
    *   `cd plugins/modbus && cargo build --target wasm32-unknown-unknown --release`。
4.  **运行**:
    *   将 `.wasm` 文件放入 `./plugins` 目录。
    *   启动 `./flux-iot-server`。
    *   通过 HTTP API 创建产品，指定使用该插件。
5.  **编写规则**:
    *   在前端界面编写 Rhai 脚本，保存到数据库。
    *   Rust 实时热加载新脚本（无需重启）。

---

此文档为您提供了一个清晰的实施蓝图。Rust 保证了基础服务的坚如磐石，Wasm 解决了物联网协议碎片化的痛点，Rhai 赋予了系统极高的业务灵活性。