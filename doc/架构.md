# FLUX IOT 飞流物联网平台架构

 利用 **Rust 的高性能与安全性**作为底座，**Wasm (WebAssembly)** 实现沙箱化、高性能的扩展能力，**Rhai** 实现轻量级的动态逻辑编排，能够很好地平衡“系统稳定性”与“业务灵活性”。

基于架构愿景，以下是对各个功能模块的实现方式建议（Rust 核心 vs 插件 vs 脚本）：

---

### 一、 核心划分原则

在分配功能之前，我们确立三个标准：

1.  **Rust 基础服务 (Core)**：涉及系统稳定性、高并发 I/O、数据库一致性、权限安全、资源调度的功能。**特点：静态编译、很少变动、高性能要求。**
2.  **Wasm 插件 (Plugins)**：涉及协议解析、复杂算法、非标准的三方对接。**特点：需要动态热更新、计算密集型、需要沙箱隔离（崩了不影响主进程）。**
3.  **Rhai 脚本 (Scripts)**：涉及用户自定义逻辑、简单的条件判断、流程编排。**特点：逻辑经常变动、轻量级、无需编译直接运行。**

---

### 二、 功能详细归类

#### 1. 适合用 Rust 写成基础服务 (Core Services)

这些是平台的“骨架”和“心脏”，必须稳健且高效。

*   **产品管理 & 设备管理**
    *   *理由*：这是元数据（Metadata），涉及数据库的一致性读写（CRUD）。设备注册、状态维护、鉴权（Auth）是高频且核心的操作，必须在 Rust 层高效处理。
*   **插件管理 (核心运行时)**
    *   *理由*：这是“宿主”程序。负责加载/卸载 Wasm 模块、管理 Rhai 引擎上下文、分配内存、调度线程。
*   **网络传输层 (TCP/UDP/WebSocket Server)**
    *   *理由*：Rust 的 `Tokio` 或 `Async-std` 处理海量连接（C1000K）是强项。**注意**：连接的建立、TLS 握手、I/O 读写应该在 Rust 层，只有**数据包内容的解析**才交给插件。
*   **系统监控 & 资源管理**
    *   *理由*：需要访问操作系统底层接口（CPU、内存、磁盘），Rust 具有天然优势。
*   **告警中心 (分发引擎)**
    *   *理由*：维护告警队列、状态机流转、防止告警风暴，需要高性能的数据结构支持。
*   **视频接入 (流媒体服务核心)**
    *   *理由*：视频流（RTMP/RTSP/WebRTC）的转发涉及大量内存拷贝和带宽吞吐，Wasm 目前处理 IO 密集型的大流量视频流会有性能损耗，建议核心流媒体转发服务用 Rust（基于 GStreamer 或 FFmpeg 绑定）。
*   **数据权限管控 (RBAC/ABAC)**
    *   *理由*：安全拦截器必须在最底层生效，不能被插件绕过。
*   **多数据库支持 (ORM/连接池)**
    *   *理由*：数据库连接池（如 `sqlx` 或 `sea-orm`）需要在核心层管理，插件只需申请数据，不应直接持有数据库连接。
*   **定时任务 (调度器)**
    *   *理由*：时间轮算法（Time Wheel）或 Cron 调度需要常驻内存且精准，适合 Rust 实现。

#### 2. 适合做成 Wasm 插件 (Plugins)

这些功能通常差异化大，需要根据不同项目动态调整，且计算量适中。

*   **文本传输协议解析 (Codec)**
    *   *场景*：私有 TCP 协议、Modbus 变种、各品牌异构的 payload 解析。
    *   *实现*：Rust 核心负责接收 `[u8]` 字节流，丢进 Wasm，Wasm 返回解析后的 JSON 或结构体。这样添加新设备协议无需重启平台。
*   **加解密插件**
    *   *场景*：某些行业（如电力、水务）有非标的加密算法。
    *   *实现*：Wasm 计算性能接近原生，非常适合执行具体的加密/解密运算算法。
*   **视频协议信令交互 (GB28181 SIP)**
    *   *场景*：GB28181 的 XML 信令解析非常繁琐且易变。
    *   *实现*：复杂的 XML 解析逻辑放在 Wasm 中，流媒体数据传输依然走 Rust 核心。
*   **第三方服务推送适配器**
    *   *场景*：告警触发后，要推送到钉钉、企业微信、或者是客户老旧的 HTTP 接口。
    *   *实现*：这些 HTTP 请求的构造逻辑适合做成插件。
*   **复杂边缘计算算法**
    *   *场景*：对设备数据进行傅里叶变换、卡尔曼滤波等清洗操作。

#### 3. 适合用 Rhai 动态脚本 (Dynamic Logic)

这些功能由“最终用户”或“实施工程师”编写，要求极低的门槛和极高的灵活性。

*   **规则引擎 (逻辑判断)**
    *   *场景*：`if (temp > 40 && humidity < 30) { trigger_alarm() }`
    *   *实现*：Rhai 专门为此设计。Rust 将设备数据注入 Rhai Scope，Rhai 执行判断逻辑并返回结果。
*   **场景联动 (流程编排)**
    *   *场景*：“回家模式”：开灯 -> 等2秒 -> 开空调 -> 播放音乐。
    *   *实现*：Rhai 脚本定义流程步骤，Rust 核心负责按步骤执行。
*   **数据清洗 (简单的字段映射)**
    *   *场景*：把 `device_id` 重命名为 `id`，或者 `value * 10`。

---

### 三、 架构设计建议图谱

为了让系统更优雅，建议采用 **"Rust 核心 + Wasm 算子 + Rhai 胶水"** 的模式：

#### 1. 协议接入层 (Protocol Layer)
*   **TCP/MQTT Listener (Rust)**: 负责维持 socket 连接，处理粘包。
*   **Protocol Parser (Wasm Plugin)**: *[推荐插件化]* 输入字节流，输出标准平台消息对象。

#### 2. 规则与逻辑层 (Logic Layer)
*   **Rule Engine Host (Rust)**: 负责订阅消息总线，查找匹配规则。
*   **Filter Logic (Rhai Script)**: *[推荐脚本化]* 用户编写的过滤逻辑。
*   **Complex Action (Wasm Plugin)**: *[推荐插件化]* 如果规则触发后需要复杂的计算或特定格式转换。

#### 3. 视频流层 (Video Layer)
*   **Stream Server (Rust)**: 负责 RTSP/RTMP 转 WebRTC/HLS，高性能转发。
*   **Signaling Handler (Wasm Plugin)**: *[推荐插件化]* 处理 GB28181 的注册、保活、PTZ 控制指令的 XML 解析。

#### 4. 存储与分析层 (Data Layer)
*   **Timeseries DB Writer (Rust)**: 高效写入 InfluxDB/TDengine。
*   **Report Calculator (Rust)**: 基础的聚合计算（Avg, Max, Min）。
*   **Custom Report (Wasm Plugin)**: 如果有非常奇怪的报表统计逻辑，可以通过 Wasm 扩展。

### 四、 总结列表

| 功能模块                     | 建议实现方式      | 理由                             |
| :--------------------------- | :---------------- | :------------------------------- |
| **产品/设备/资源管理**       | **Rust 基础服务** | 核心元数据，强一致性要求         |
| **系统监控/数据权限**        | **Rust 基础服务** | 涉及底层系统资源与安全           |
| **MQTT/HTTP 服务端**         | **Rust 基础服务** | 通用标准协议，要求高并发性能     |
| **视频流转发 (RTMP/RTSP)**   | **Rust 基础服务** | 极高的网络 I/O 和内存带宽要求    |
| **定时任务/告警分发**        | **Rust 基础服务** | 核心调度逻辑，要求稳定           |
| **私有 TCP/Modbus 解析**     | **Wasm 插件**     | 协议碎片化严重，需动态支持新设备 |
| **加解密/签名算法**          | **Wasm 插件**     | 计算密集且标准多变               |
| **视频信令 (GB28181 SIP)**   | **Wasm 插件**     | 文本解析复杂，与流媒体数据分离   |
| **外部通知 (钉钉/邮件适配)** | **Wasm 插件**     | 第三方 API 经常变动              |
| **规则引擎 (判断条件)**      | **Rhai 脚本**     | 业务逻辑极易变，轻量级嵌入       |
| **场景联动 (执行流)**        | **Rhai 脚本**     | 用户自定义的业务流程             |
| **简单数据转换**             | **Rhai 脚本**     | 在线编辑，即时生效               |

**核心建议**：
尽量保持 Rust 核心的**纯净**和**通用性**。凡是“标准”的东西（如 MQTT 协议、SQL 写入）放 Rust 里；凡是“特异”的东西（如某厂家自定义的二进制协议、某客户定制的联动逻辑）放 Wasm/Rhai 里。