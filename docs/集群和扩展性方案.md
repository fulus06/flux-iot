# FLUX IOT é›†ç¾¤å’Œæ‰©å±•æ€§æ–¹æ¡ˆ

## ğŸ“‹ ç›®å½•

1. [å•èŠ‚ç‚¹æ¶æ„åˆ†æ](#å•èŠ‚ç‚¹æ¶æ„åˆ†æ)
2. [å¤šèŠ‚ç‚¹éƒ¨ç½²æ–¹æ¡ˆ](#å¤šèŠ‚ç‚¹éƒ¨ç½²æ–¹æ¡ˆ)
3. [Redis åˆ†å¸ƒå¼ EventBus](#redis-åˆ†å¸ƒå¼-eventbus)
4. [æ•°æ®åº“è¯»å†™åˆ†ç¦»](#æ•°æ®åº“è¯»å†™åˆ†ç¦»)
5. [æ°´å¹³æ‰©å±•æ–¹æ¡ˆ](#æ°´å¹³æ‰©å±•æ–¹æ¡ˆ)
6. [æ€§èƒ½å¯¹æ¯”åˆ†æ](#æ€§èƒ½å¯¹æ¯”åˆ†æ)
7. [å®æ–½è·¯çº¿å›¾](#å®æ–½è·¯çº¿å›¾)
8. [æœ€ä½³å®è·µå»ºè®®](#æœ€ä½³å®è·µå»ºè®®)

---

## 1. å•èŠ‚ç‚¹æ¶æ„åˆ†æ

### 1.1 å½“å‰æ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         FLUX IOT (å•èŠ‚ç‚¹)                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  HTTP API (3000)  â”‚  MQTT (1883/8883)   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚      å†…å­˜ EventBus (tokio::broadcast)    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Wasm Engine  â”‚  Rhai Engine           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚      PostgreSQL (å•å®ä¾‹)                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.2 å•èŠ‚ç‚¹é™åˆ¶

| é™åˆ¶ç±»å‹ | é—®é¢˜æè¿° | å½±å“ |
|---------|---------|------|
| **æ€§èƒ½ç“¶é¢ˆ** | å•æœº CPU/å†…å­˜é™åˆ¶ | æ— æ³•å¤„ç†å¤§è§„æ¨¡å¹¶å‘ |
| **å•ç‚¹æ•…éšœ** | èŠ‚ç‚¹å®•æœºæœåŠ¡ä¸å¯ç”¨ | å¯ç”¨æ€§ 99.9% â†’ åœæœº 8.76 å°æ—¶/å¹´ |
| **æ‰©å±•æ€§** | å‚ç›´æ‰©å±•æˆæœ¬é«˜ | ç¡¬ä»¶å‡çº§æœ‰ä¸Šé™ |
| **EventBus** | å†…å­˜æ¶ˆæ¯æ— æ³•è·¨èŠ‚ç‚¹ | MQTT å®¢æˆ·ç«¯åªèƒ½è¿æ¥å•èŠ‚ç‚¹ |
| **æ•°æ®åº“** | å•ç‚¹è¯»å†™å‹åŠ›å¤§ | é«˜å¹¶å‘ä¸‹æ€§èƒ½ä¸‹é™ |
| **åœ°åŸŸé™åˆ¶** | å•æœºæˆ¿éƒ¨ç½² | è·¨åœ°åŸŸå»¶è¿Ÿé«˜ |

### 1.3 æ€§èƒ½æŒ‡æ ‡ï¼ˆå•èŠ‚ç‚¹ï¼‰

| æŒ‡æ ‡ | å½“å‰å€¼ | ç“¶é¢ˆ |
|------|--------|------|
| **HTTP QPS** | ~5,000 | CPU å¯†é›†å‹æ“ä½œ |
| **MQTT è¿æ¥æ•°** | ~10,000 | å†…å­˜é™åˆ¶ |
| **æ¶ˆæ¯åå** | ~50,000 msg/s | EventBus å†…å­˜å¸¦å®½ |
| **æ•°æ®åº“ TPS** | ~2,000 | ç£ç›˜ I/O |
| **å¯ç”¨æ€§** | 99.9% | å•ç‚¹æ•…éšœ |

---

## 2. å¤šèŠ‚ç‚¹éƒ¨ç½²æ–¹æ¡ˆ

### 2.1 æ¶æ„æ¼”è¿›è·¯çº¿

```
é˜¶æ®µ 1: å•èŠ‚ç‚¹          é˜¶æ®µ 2: ä¸»ä»å¤åˆ¶        é˜¶æ®µ 3: å¤šæ´»é›†ç¾¤
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ FLUX-1  â”‚           â”‚ FLUX-1  â”‚            â”‚ FLUX-1  â”‚
â”‚ (ä¸»èŠ‚ç‚¹) â”‚    â†’      â”‚ (ä¸»)    â”‚     â†’      â”‚ (èŠ‚ç‚¹1) â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚         â”‚            â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
                      â”‚ FLUX-2  â”‚            â”‚ FLUX-2  â”‚
                      â”‚ (ä»)    â”‚            â”‚ (èŠ‚ç‚¹2) â”‚
                      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
                                             â”‚ FLUX-N  â”‚
                                             â”‚ (èŠ‚ç‚¹N) â”‚
                                             â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.2 ç›®æ ‡æ¶æ„ï¼ˆå¤šæ´»é›†ç¾¤ï¼‰

```
                    Internet
                        â”‚
                   â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”
                   â”‚  Nginx  â”‚ (è´Ÿè½½å‡è¡¡)
                   â”‚  LVS    â”‚
                   â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
                        â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚               â”‚               â”‚
   â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”
   â”‚ FLUX-1  â”‚     â”‚ FLUX-2  â”‚     â”‚ FLUX-N  â”‚
   â”‚ HTTP    â”‚     â”‚ HTTP    â”‚     â”‚ HTTP    â”‚
   â”‚ MQTT    â”‚     â”‚ MQTT    â”‚     â”‚ MQTT    â”‚
   â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
        â”‚               â”‚               â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â”‚
                â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”
                â”‚ Redis Cluster  â”‚ (åˆ†å¸ƒå¼ EventBus)
                â”‚ Pub/Sub        â”‚
                â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚               â”‚               â”‚
   â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”
   â”‚ PG ä¸»åº“  â”‚â”€â”€â”€â”€â–¶â”‚ PG ä»åº“1 â”‚    â”‚ PG ä»åº“2 â”‚
   â”‚ (å†™)    â”‚     â”‚ (è¯»)    â”‚     â”‚ (è¯»)    â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.3 å…³é”®ç»„ä»¶è®¾è®¡

#### A. è´Ÿè½½å‡è¡¡å±‚

**Nginx + Keepalived (é«˜å¯ç”¨)**

```nginx
# nginx.conf
upstream flux_http {
    least_conn;  # æœ€å°‘è¿æ¥ç®—æ³•
    server flux-1:3000 max_fails=3 fail_timeout=30s;
    server flux-2:3000 max_fails=3 fail_timeout=30s;
    server flux-3:3000 max_fails=3 fail_timeout=30s;
    keepalive 64;
}

upstream flux_mqtt {
    hash $remote_addr consistent;  # ä¸€è‡´æ€§å“ˆå¸Œï¼ˆä¿æŒè¿æ¥ï¼‰
    server flux-1:1883 max_fails=3 fail_timeout=30s;
    server flux-2:1883 max_fails=3 fail_timeout=30s;
    server flux-3:1883 max_fails=3 fail_timeout=30s;
}
```

**è´Ÿè½½å‡è¡¡ç­–ç•¥**:
- **HTTP API**: æœ€å°‘è¿æ¥ï¼ˆLeast Connectionsï¼‰
- **MQTT**: ä¸€è‡´æ€§å“ˆå¸Œï¼ˆä¿æŒå®¢æˆ·ç«¯è¿æ¥åˆ°åŒä¸€èŠ‚ç‚¹ï¼‰
- **å¥åº·æ£€æŸ¥**: æ¯ 10 ç§’æ£€æŸ¥ä¸€æ¬¡

#### B. æœåŠ¡å‘ç°

**Consul / etcd**

```rust
// æœåŠ¡æ³¨å†Œ
pub struct ServiceRegistry {
    consul_client: ConsulClient,
    node_id: String,
    service_info: ServiceInfo,
}

impl ServiceRegistry {
    pub async fn register(&self) -> Result<()> {
        let registration = ServiceRegistration {
            id: self.node_id.clone(),
            name: "flux-iot",
            address: self.service_info.address.clone(),
            port: self.service_info.port,
            tags: vec!["http", "mqtt"],
            check: HealthCheck {
                http: format!("http://{}:{}/health", 
                    self.service_info.address, 
                    self.service_info.port),
                interval: "10s",
                timeout: "3s",
            },
        };
        
        self.consul_client.register(registration).await
    }
}
```

---

## 3. Redis åˆ†å¸ƒå¼ EventBus

### 3.1 æ¶æ„è®¾è®¡

**ä»å†…å­˜ EventBus åˆ° Redis Pub/Sub**

```rust
// å½“å‰ï¼šå†…å­˜ EventBus
pub struct EventBus {
    channels: HashMap<String, broadcast::Sender<Event>>,
}

// å‡çº§ï¼šRedis EventBus
pub struct RedisEventBus {
    redis_pool: RedisPool,
    local_cache: Arc<RwLock<HashMap<String, Vec<Event>>>>,
    node_id: String,
}
```

### 3.2 å®ç°æ–¹æ¡ˆå¯¹æ¯”

#### æ–¹æ¡ˆ A: Redis Pub/Subï¼ˆæ¨èç”¨äºå®æ—¶æ€§ï¼‰

**ä¼˜ç‚¹**:
- ç®€å•æ˜“ç”¨
- ä½å»¶è¿Ÿï¼ˆ< 5msï¼‰
- æ”¯æŒæ¨¡å¼åŒ¹é…è®¢é˜…

**ç¼ºç‚¹**:
- æ¶ˆæ¯ä¸æŒä¹…åŒ–
- æ— æ³•ä¿è¯å¯é æ€§

```rust
use redis::aio::ConnectionManager;
use redis::AsyncCommands;

pub struct RedisPubSubBus {
    publisher: ConnectionManager,
    subscriber: redis::aio::PubSub,
    node_id: String,
}

impl RedisPubSubBus {
    pub async fn publish(&self, topic: &str, event: &Event) -> Result<()> {
        let payload = serde_json::to_string(event)?;
        let channel = format!("flux:events:{}", topic);
        
        self.publisher
            .clone()
            .publish(&channel, payload)
            .await
            .map_err(|e| FluxError::EventBus(e.to_string()))?;
        
        Ok(())
    }
    
    pub async fn subscribe(&mut self, pattern: &str) -> Result<()> {
        let channel_pattern = format!("flux:events:{}", pattern);
        self.subscriber.psubscribe(&channel_pattern).await?;
        Ok(())
    }
    
    pub async fn receive(&mut self) -> Result<Event> {
        let msg = self.subscriber.on_message().next().await
            .ok_or_else(|| FluxError::EventBus("No message".into()))?;
        
        let payload: String = msg.get_payload()?;
        let event: Event = serde_json::from_str(&payload)?;
        
        Ok(event)
    }
}
```

#### æ–¹æ¡ˆ B: Redis Streamsï¼ˆæ¨èç”¨äºå¯é æ€§ï¼‰

**ä¼˜ç‚¹**:
- æ¶ˆæ¯æŒä¹…åŒ–
- æ”¯æŒæ¶ˆè´¹è€…ç»„
- å¯é æ€§é«˜

**ç¼ºç‚¹**:
- å»¶è¿Ÿç¨é«˜ï¼ˆ~10msï¼‰
- å¤æ‚åº¦å¢åŠ 

```rust
pub struct RedisStreamBus {
    redis: ConnectionManager,
    consumer_group: String,
    consumer_id: String,
}

impl RedisStreamBus {
    pub async fn publish(&self, topic: &str, event: &Event) -> Result<String> {
        let stream_key = format!("flux:stream:{}", topic);
        let payload = serde_json::to_string(event)?;
        
        let id: String = redis::cmd("XADD")
            .arg(&stream_key)
            .arg("*")  // è‡ªåŠ¨ç”Ÿæˆ ID
            .arg("data")
            .arg(payload)
            .query_async(&mut self.redis.clone())
            .await?;
        
        Ok(id)
    }
    
    pub async fn consume(&self, topic: &str) -> Result<Vec<Event>> {
        let stream_key = format!("flux:stream:{}", topic);
        
        // ä½¿ç”¨æ¶ˆè´¹è€…ç»„è¯»å–
        let results: Vec<(String, Vec<(String, String)>)> = redis::cmd("XREADGROUP")
            .arg("GROUP")
            .arg(&self.consumer_group)
            .arg(&self.consumer_id)
            .arg("COUNT")
            .arg(100)
            .arg("BLOCK")
            .arg(1000)  // 1 ç§’è¶…æ—¶
            .arg("STREAMS")
            .arg(&stream_key)
            .arg(">")  // åªè¯»å–æ–°æ¶ˆæ¯
            .query_async(&mut self.redis.clone())
            .await?;
        
        // è§£æäº‹ä»¶
        let mut events = Vec::new();
        for (_, entries) in results {
            for (_, data) in entries {
                if let Ok(event) = serde_json::from_str::<Event>(&data) {
                    events.push(event);
                }
            }
        }
        
        Ok(events)
    }
}
```

#### æ–¹æ¡ˆ C: æ··åˆæ–¹æ¡ˆï¼ˆç”Ÿäº§ç¯å¢ƒæ¨èï¼‰â­

**æœ¬åœ°ç¼“å­˜ + Redis**

```rust
pub struct HybridEventBus {
    // æœ¬åœ°å†…å­˜ç¼“å­˜ï¼ˆå¿«é€Ÿè®¿é—®ï¼‰
    local: Arc<RwLock<HashMap<String, broadcast::Sender<Event>>>>,
    
    // Redis åˆ†å¸ƒå¼æ€»çº¿ï¼ˆè·¨èŠ‚ç‚¹ï¼‰
    redis: RedisPubSubBus,
    
    // è®¢é˜…ç®¡ç†
    subscriptions: Arc<RwLock<HashSet<String>>>,
}

impl HybridEventBus {
    pub async fn publish(&self, topic: &str, event: Event) -> Result<()> {
        // 1. æœ¬åœ°å¹¿æ’­ï¼ˆåŒèŠ‚ç‚¹è®¢é˜…è€…ï¼‰
        if let Some(sender) = self.local.read().await.get(topic) {
            let _ = sender.send(event.clone());
        }
        
        // 2. Redis å¹¿æ’­ï¼ˆè·¨èŠ‚ç‚¹ï¼‰
        self.redis.publish(topic, &event).await?;
        
        Ok(())
    }
    
    pub async fn subscribe(&self, topic: &str) -> broadcast::Receiver<Event> {
        // 1. æœ¬åœ°è®¢é˜…
        let receiver = {
            let mut local = self.local.write().await;
            local.entry(topic.to_string())
                .or_insert_with(|| broadcast::channel(1024).0)
                .subscribe()
        };
        
        // 2. Redis è®¢é˜…ï¼ˆå¦‚æœæ˜¯æ–°ä¸»é¢˜ï¼‰
        let mut subs = self.subscriptions.write().await;
        if !subs.contains(topic) {
            self.redis.subscribe(topic).await?;
            subs.insert(topic.to_string());
        }
        
        receiver
    }
}
```

### 3.3 æ€§èƒ½å¯¹æ¯”

| æ–¹æ¡ˆ | å»¶è¿Ÿ | ååé‡ | å¯é æ€§ | æ¨èåœºæ™¯ |
|------|------|--------|--------|---------|
| **å†…å­˜ EventBus** | < 1ms | 100K msg/s | ä½ | å•èŠ‚ç‚¹ |
| **Redis Pub/Sub** | ~5ms | 50K msg/s | ä¸­ | å®æ—¶æ€§è¦æ±‚é«˜ |
| **Redis Streams** | ~10ms | 30K msg/s | é«˜ | å¯é æ€§è¦æ±‚é«˜ |
| **æ··åˆæ–¹æ¡ˆ** | 1-5ms | 80K msg/s | é«˜ | ç”Ÿäº§ç¯å¢ƒ â­ |

---

## 4. æ•°æ®åº“è¯»å†™åˆ†ç¦»

### 4.1 æ¶æ„è®¾è®¡

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          åº”ç”¨å±‚ (FLUX IOT)                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚ å†™æ“ä½œ     â”‚      â”‚ è¯»æ“ä½œ     â”‚     â”‚
â”‚  â”‚ (INSERT,   â”‚      â”‚ (SELECT)   â”‚     â”‚
â”‚  â”‚  UPDATE,   â”‚      â”‚            â”‚     â”‚
â”‚  â”‚  DELETE)   â”‚      â”‚            â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚                    â”‚
         â”‚                    â”‚ (è´Ÿè½½å‡è¡¡)
         â”‚              â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”
         â”‚              â”‚           â”‚     â”‚
    â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â–¼â”€â”€â”€â”  â”Œâ”€â”€â”€â–¼â”€â”€â”€â” â”‚
    â”‚ PG ä¸»åº“  â”‚â”€â”€â”€â–¶â”‚ä»åº“ 1  â”‚  â”‚ä»åº“ 2  â”‚ â”‚
    â”‚ (Master)â”‚    â”‚(Slave)â”‚  â”‚(Slave)â”‚ â”‚
    â”‚  å†™+è¯»  â”‚    â”‚  åªè¯»  â”‚  â”‚  åªè¯»  â”‚ â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
         â”‚              â”‚           â”‚     â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”˜
              æµå¤åˆ¶ (Streaming Replication)
```

### 4.2 å®ç°æ–¹æ¡ˆ

#### A. SeaORM è¿æ¥æ± é…ç½®

```rust
use sea_orm::{Database, DatabaseConnection, ConnectOptions};

pub struct DatabaseCluster {
    master: DatabaseConnection,
    slaves: Vec<DatabaseConnection>,
    current_slave: AtomicUsize,
}

impl DatabaseCluster {
    pub async fn new(config: &DatabaseConfig) -> Result<Self> {
        // ä¸»åº“è¿æ¥
        let mut master_opts = ConnectOptions::new(&config.master_url);
        master_opts
            .max_connections(100)
            .min_connections(5)
            .connect_timeout(Duration::from_secs(8))
            .idle_timeout(Duration::from_secs(300))
            .sqlx_logging(true);
        
        let master = Database::connect(master_opts).await?;
        
        // ä»åº“è¿æ¥æ± 
        let mut slaves = Vec::new();
        for slave_url in &config.slave_urls {
            let mut slave_opts = ConnectOptions::new(slave_url);
            slave_opts
                .max_connections(50)
                .min_connections(5)
                .connect_timeout(Duration::from_secs(8))
                .idle_timeout(Duration::from_secs(300))
                .sqlx_logging(false);  // ä»åº“ä¸è®°å½•æ—¥å¿—
            
            slaves.push(Database::connect(slave_opts).await?);
        }
        
        Ok(Self {
            master,
            slaves,
            current_slave: AtomicUsize::new(0),
        })
    }
    
    /// è·å–å†™è¿æ¥ï¼ˆä¸»åº“ï¼‰
    pub fn writer(&self) -> &DatabaseConnection {
        &self.master
    }
    
    /// è·å–è¯»è¿æ¥ï¼ˆä»åº“ï¼Œè½®è¯¢ï¼‰
    pub fn reader(&self) -> &DatabaseConnection {
        if self.slaves.is_empty() {
            return &self.master;
        }
        
        let idx = self.current_slave.fetch_add(1, Ordering::Relaxed) % self.slaves.len();
        &self.slaves[idx]
    }
}
```

#### B. è‡ªåŠ¨è·¯ç”±

```rust
pub trait DatabaseRouter {
    fn get_connection(&self, operation: DbOperation) -> &DatabaseConnection;
}

pub enum DbOperation {
    Read,
    Write,
}

impl DatabaseRouter for DatabaseCluster {
    fn get_connection(&self, operation: DbOperation) -> &DatabaseConnection {
        match operation {
            DbOperation::Write => self.writer(),
            DbOperation::Read => self.reader(),
        }
    }
}

// ä½¿ç”¨ç¤ºä¾‹
impl RuleRepository {
    pub async fn find_by_id(&self, id: i32) -> Result<Option<Rule>> {
        let db = self.cluster.get_connection(DbOperation::Read);
        
        rule::Entity::find_by_id(id)
            .one(db)
            .await
            .map_err(|e| FluxError::Database(e))
    }
    
    pub async fn create(&self, rule: Rule) -> Result<Rule> {
        let db = self.cluster.get_connection(DbOperation::Write);
        
        rule::ActiveModel::from(rule)
            .insert(db)
            .await
            .map_err(|e| FluxError::Database(e))
    }
}
```

#### C. ä¸»ä»å»¶è¿Ÿå¤„ç†

```rust
pub struct ReplicationMonitor {
    cluster: Arc<DatabaseCluster>,
}

impl ReplicationMonitor {
    /// æ£€æŸ¥ä¸»ä»å»¶è¿Ÿ
    pub async fn check_lag(&self) -> Result<Duration> {
        // åœ¨ä¸»åº“å†™å…¥æ—¶é—´æˆ³
        let master_time: i64 = sqlx::query_scalar(
            "SELECT EXTRACT(EPOCH FROM NOW())::BIGINT"
        )
        .fetch_one(self.cluster.writer())
        .await?;
        
        // åœ¨ä»åº“è¯»å–å¤åˆ¶å»¶è¿Ÿ
        let slave_lag: i64 = sqlx::query_scalar(
            "SELECT EXTRACT(EPOCH FROM NOW() - pg_last_xact_replay_timestamp())::BIGINT"
        )
        .fetch_one(self.cluster.reader())
        .await?;
        
        Ok(Duration::from_secs(slave_lag as u64))
    }
    
    /// å¦‚æœå»¶è¿Ÿè¿‡å¤§ï¼Œé™çº§åˆ°ä¸»åº“è¯»å–
    pub async fn get_reader_with_fallback(&self) -> &DatabaseConnection {
        match self.check_lag().await {
            Ok(lag) if lag < Duration::from_secs(5) => self.cluster.reader(),
            _ => {
                tracing::warn!("Slave lag too high, falling back to master");
                self.cluster.writer()
            }
        }
    }
}
```

### 4.3 é…ç½®ç¤ºä¾‹

```toml
# config.toml
[database]
# ä¸»åº“ï¼ˆå†™ï¼‰
master_url = "postgres://flux:password@pg-master:5432/flux_iot"

# ä»åº“ï¼ˆè¯»ï¼‰
slave_urls = [
    "postgres://flux:password@pg-slave-1:5432/flux_iot",
    "postgres://flux:password@pg-slave-2:5432/flux_iot",
]

# è¿æ¥æ± é…ç½®
max_connections = 100
min_connections = 5
connect_timeout = 8
idle_timeout = 300

# ä¸»ä»å»¶è¿Ÿé˜ˆå€¼ï¼ˆç§’ï¼‰
max_replication_lag = 5
```

### 4.4 PostgreSQL ä¸»ä»é…ç½®

#### ä¸»åº“é…ç½® (postgresql.conf)

```conf
# å¯ç”¨æµå¤åˆ¶
wal_level = replica
max_wal_senders = 10
wal_keep_size = 1GB
hot_standby = on

# æ€§èƒ½ä¼˜åŒ–
shared_buffers = 256MB
effective_cache_size = 1GB
maintenance_work_mem = 64MB
checkpoint_completion_target = 0.9
wal_buffers = 16MB
default_statistics_target = 100
random_page_cost = 1.1
effective_io_concurrency = 200
work_mem = 4MB
min_wal_size = 1GB
max_wal_size = 4GB
```

#### ä»åº“é…ç½® (recovery.conf)

```conf
standby_mode = 'on'
primary_conninfo = 'host=pg-master port=5432 user=replicator password=password'
trigger_file = '/tmp/postgresql.trigger.5432'
```

---

## 5. æ°´å¹³æ‰©å±•æ–¹æ¡ˆ

### 5.1 æ‰©å±•ç»´åº¦

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          æ°´å¹³æ‰©å±•ç­–ç•¥                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  1. æ— çŠ¶æ€æœåŠ¡æ‰©å±• (FLUX IOT èŠ‚ç‚¹)          â”‚
â”‚     - å¢åŠ èŠ‚ç‚¹æ•°é‡                           â”‚
â”‚     - è´Ÿè½½å‡è¡¡åˆ†å‘                           â”‚
â”‚                                             â”‚
â”‚  2. æœ‰çŠ¶æ€æœåŠ¡æ‰©å±•                           â”‚
â”‚     - Redis Cluster (åˆ†ç‰‡)                  â”‚
â”‚     - PostgreSQL (ä¸»ä»å¤åˆ¶ + åˆ†ç‰‡)          â”‚
â”‚                                             â”‚
â”‚  3. åŠŸèƒ½æ¨¡å—æ‹†åˆ†                             â”‚
â”‚     - HTTP API æœåŠ¡                         â”‚
â”‚     - MQTT Broker æœåŠ¡                      â”‚
â”‚     - æ’ä»¶æ‰§è¡ŒæœåŠ¡                           â”‚
â”‚     - è§„åˆ™å¼•æ“æœåŠ¡                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5.2 æ‰©å±•ç­–ç•¥

#### A. æŒ‰åŠŸèƒ½æ‹†åˆ†ï¼ˆå¾®æœåŠ¡åŒ–ï¼‰

```
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚ API Gateway  â”‚
                    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
                           â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚                  â”‚                  â”‚
   â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”
   â”‚ HTTP    â”‚       â”‚ MQTT      â”‚     â”‚ Plugin    â”‚
   â”‚ Service â”‚       â”‚ Service   â”‚     â”‚ Service   â”‚
   â”‚ (API)   â”‚       â”‚ (Broker)  â”‚     â”‚ (Wasm)    â”‚
   â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜       â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
        â”‚                  â”‚                  â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚ Redis Clusterâ”‚
                    â”‚ (EventBus)   â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**æ‹†åˆ†åçš„æœåŠ¡**:

1. **HTTP API æœåŠ¡**
   - å¤„ç† REST API è¯·æ±‚
   - è§„åˆ™ç®¡ç†
   - äº‹ä»¶æ¥æ”¶

2. **MQTT Broker æœåŠ¡**
   - MQTT è¿æ¥ç®¡ç†
   - æ¶ˆæ¯è·¯ç”±
   - QoS ä¿è¯

3. **Plugin æ‰§è¡ŒæœåŠ¡**
   - Wasm æ’ä»¶åŠ è½½
   - æ’ä»¶æ‰§è¡Œ
   - èµ„æºéš”ç¦»

4. **Rule å¼•æ“æœåŠ¡**
   - Rhai è„šæœ¬æ‰§è¡Œ
   - è§„åˆ™åŒ¹é…
   - äº‹ä»¶å¤„ç†

#### B. æŒ‰è´Ÿè½½åˆ†ç‰‡

**MQTT è¿æ¥åˆ†ç‰‡**:

```rust
pub struct MqttSharding {
    shard_count: usize,
}

impl MqttSharding {
    /// æ ¹æ®å®¢æˆ·ç«¯ ID è®¡ç®—åˆ†ç‰‡
    pub fn get_shard(&self, client_id: &str) -> usize {
        use std::collections::hash_map::DefaultHasher;
        use std::hash::{Hash, Hasher};
        
        let mut hasher = DefaultHasher::new();
        client_id.hash(&mut hasher);
        (hasher.finish() as usize) % self.shard_count
    }
    
    /// è·å–å¯¹åº”åˆ†ç‰‡çš„èŠ‚ç‚¹
    pub fn get_node(&self, client_id: &str, nodes: &[String]) -> &str {
        let shard = self.get_shard(client_id);
        &nodes[shard % nodes.len()]
    }
}
```

**æ•°æ®åº“åˆ†ç‰‡**:

```sql
-- æŒ‰è®¾å¤‡ ID èŒƒå›´åˆ†ç‰‡
CREATE TABLE devices_shard_0 (
    LIKE devices INCLUDING ALL
) INHERITS (devices);

CREATE TABLE devices_shard_1 (
    LIKE devices INCLUDING ALL
) INHERITS (devices);

-- åˆ†ç‰‡è§„åˆ™
CREATE OR REPLACE FUNCTION devices_insert_trigger()
RETURNS TRIGGER AS $$
BEGIN
    IF (NEW.device_id % 2 = 0) THEN
        INSERT INTO devices_shard_0 VALUES (NEW.*);
    ELSE
        INSERT INTO devices_shard_1 VALUES (NEW.*);
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;
```

### 5.3 è‡ªåŠ¨æ‰©ç¼©å®¹

**Kubernetes HPA (Horizontal Pod Autoscaler)**

```yaml
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: flux-iot-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: flux-iot
  minReplicas: 3
  maxReplicas: 20
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 80
  - type: Pods
    pods:
      metric:
        name: mqtt_connections
      target:
        type: AverageValue
        averageValue: "5000"
  behavior:
    scaleDown:
      stabilizationWindowSeconds: 300
      policies:
      - type: Percent
        value: 50
        periodSeconds: 60
    scaleUp:
      stabilizationWindowSeconds: 0
      policies:
      - type: Percent
        value: 100
        periodSeconds: 15
      - type: Pods
        value: 4
        periodSeconds: 15
      selectPolicy: Max
```

---

## 6. æ€§èƒ½å¯¹æ¯”åˆ†æ

### 6.1 å•èŠ‚ç‚¹ vs é›†ç¾¤

| æŒ‡æ ‡ | å•èŠ‚ç‚¹ | 3èŠ‚ç‚¹é›†ç¾¤ | 10èŠ‚ç‚¹é›†ç¾¤ |
|------|--------|----------|-----------|
| **HTTP QPS** | 5,000 | 15,000 | 50,000 |
| **MQTT è¿æ¥** | 10,000 | 30,000 | 100,000 |
| **æ¶ˆæ¯åå** | 50K msg/s | 150K msg/s | 500K msg/s |
| **æ•°æ®åº“ TPS** | 2,000 | 6,000 (è¯»å†™åˆ†ç¦») | 20,000 |
| **å¯ç”¨æ€§** | 99.9% | 99.95% | 99.99% |
| **æ•…éšœæ¢å¤** | æ‰‹åŠ¨ | è‡ªåŠ¨ (30s) | è‡ªåŠ¨ (10s) |

### 6.2 æˆæœ¬åˆ†æ

| é…ç½® | æœˆæˆæœ¬ | æ€§èƒ½æå‡ | ROI |
|------|--------|---------|-----|
| **å•èŠ‚ç‚¹** (8C/16G) | $200 | åŸºå‡† | - |
| **3èŠ‚ç‚¹é›†ç¾¤** (4C/8G Ã— 3) | $450 | 3x | 1.5x |
| **10èŠ‚ç‚¹é›†ç¾¤** (4C/8G Ã— 10) | $1,500 | 10x | 1.33x |
| **+ Redis Cluster** (3èŠ‚ç‚¹) | +$300 | +20% | - |
| **+ PG ä¸»ä»** (1ä¸»2ä») | +$600 | +50% | - |

### 6.3 æ‰©å±•æ€§æ›²çº¿

```
æ€§èƒ½
 â”‚
 â”‚                                    â”Œâ”€â”€â”€â”€â”€â”€â”€ å¾®æœåŠ¡åŒ–
 â”‚                              â”Œâ”€â”€â”€â”€â”€â”˜
 â”‚                        â”Œâ”€â”€â”€â”€â”€â”˜
 â”‚                  â”Œâ”€â”€â”€â”€â”€â”˜
 â”‚            â”Œâ”€â”€â”€â”€â”€â”˜           å¤šæ´»é›†ç¾¤
 â”‚      â”Œâ”€â”€â”€â”€â”€â”˜
 â”‚ â”Œâ”€â”€â”€â”€â”˜                       è¯»å†™åˆ†ç¦»
 â”‚â”€â”˜
 â”‚  å•èŠ‚ç‚¹
 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º æˆæœ¬
```

---

## 7. å®æ–½è·¯çº¿å›¾

### é˜¶æ®µ 1: å‡†å¤‡é˜¶æ®µï¼ˆ1-2 å‘¨ï¼‰

**ç›®æ ‡**: ä»£ç é‡æ„ï¼Œæ”¯æŒå¤šç§ EventBus å’Œæ•°æ®åº“å®ç°

- [ ] æŠ½è±¡ EventBus trait æ¥å£
- [ ] æŠ½è±¡ Database trait æ¥å£
- [ ] æ·»åŠ æœåŠ¡æ³¨å†Œå‘ç°æ”¯æŒï¼ˆConsulï¼‰
- [ ] æ·»åŠ é…ç½®ä¸­å¿ƒæ”¯æŒ
- [ ] ä»£ç å®¡æŸ¥å’Œæµ‹è¯•

**äº¤ä»˜ç‰©**:
- EventBus trait å®šä¹‰
- Database trait å®šä¹‰
- æœåŠ¡æ³¨å†Œæ¨¡å—
- å•å…ƒæµ‹è¯•

### é˜¶æ®µ 2: Redis EventBusï¼ˆ2-3 å‘¨ï¼‰

**ç›®æ ‡**: å®ç°åˆ†å¸ƒå¼ EventBus

- [ ] å®ç° Redis Pub/Sub EventBus
- [ ] å®ç° Redis Streams EventBus
- [ ] å®ç°æ··åˆ EventBusï¼ˆæœ¬åœ°+Redisï¼‰
- [ ] æ€§èƒ½æµ‹è¯•å’Œä¼˜åŒ–
- [ ] ç°åº¦å‘å¸ƒ

**äº¤ä»˜ç‰©**:
- Redis EventBus å®ç°
- æ€§èƒ½æµ‹è¯•æŠ¥å‘Š
- éƒ¨ç½²æ–‡æ¡£

### é˜¶æ®µ 3: æ•°æ®åº“è¯»å†™åˆ†ç¦»ï¼ˆ2 å‘¨ï¼‰

**ç›®æ ‡**: æå‡æ•°æ®åº“æ€§èƒ½

- [ ] é…ç½® PostgreSQL ä¸»ä»å¤åˆ¶
- [ ] å®ç°è¿æ¥æ± ç®¡ç†
- [ ] å®ç°è¯»å†™è·¯ç”±
- [ ] ç›‘æ§ä¸»ä»å»¶è¿Ÿ
- [ ] æ•…éšœåˆ‡æ¢æµ‹è¯•

**äº¤ä»˜ç‰©**:
- DatabaseCluster å®ç°
- ä¸»ä»é…ç½®è„šæœ¬
- ç›‘æ§é¢æ¿

### é˜¶æ®µ 4: å¤šèŠ‚ç‚¹éƒ¨ç½²ï¼ˆ1-2 å‘¨ï¼‰

**ç›®æ ‡**: å®ç°é«˜å¯ç”¨é›†ç¾¤

- [ ] é…ç½®è´Ÿè½½å‡è¡¡ï¼ˆNginx + Keepalivedï¼‰
- [ ] éƒ¨ç½²å¤šä¸ªèŠ‚ç‚¹
- [ ] é…ç½®å¥åº·æ£€æŸ¥
- [ ] å‹åŠ›æµ‹è¯•
- [ ] æ•…éšœæ¼”ç»ƒ

**äº¤ä»˜ç‰©**:
- è´Ÿè½½å‡è¡¡é…ç½®
- éƒ¨ç½²è„šæœ¬
- å‹æµ‹æŠ¥å‘Š

### é˜¶æ®µ 5: è‡ªåŠ¨æ‰©ç¼©å®¹ï¼ˆ1 å‘¨ï¼‰

**ç›®æ ‡**: å®ç°å¼¹æ€§ä¼¸ç¼©

- [ ] Kubernetes éƒ¨ç½²
- [ ] é…ç½® HPA
- [ ] ç›‘æ§å’Œå‘Šè­¦
- [ ] æ–‡æ¡£å®Œå–„
- [ ] è¿ç»´åŸ¹è®­

**äº¤ä»˜ç‰©**:
- K8s éƒ¨ç½²æ–‡ä»¶
- HPA é…ç½®
- è¿ç»´æ‰‹å†Œ

**æ€»è®¡**: 7-10 å‘¨

---

## 8. æœ€ä½³å®è·µå»ºè®®

### 8.1 æ¸è¿›å¼æ¼”è¿›

```
å•èŠ‚ç‚¹ â†’ ä¸»ä»å¤åˆ¶ â†’ è¯»å†™åˆ†ç¦» â†’ å¤šæ´»é›†ç¾¤ â†’ å¾®æœåŠ¡åŒ–
  â†“         â†“           â†“           â†“           â†“
 ç®€å•     ä¸­ç­‰        å¤æ‚       å¾ˆå¤æ‚     æå¤æ‚
```

**å»ºè®®è·¯å¾„**:
1. **< 1ä¸‡è®¾å¤‡**: å•èŠ‚ç‚¹ + å‚ç›´æ‰©å±•
2. **1-5ä¸‡è®¾å¤‡**: ä¸»ä»å¤åˆ¶ + è¯»å†™åˆ†ç¦»
3. **5-20ä¸‡è®¾å¤‡**: 3-5èŠ‚ç‚¹é›†ç¾¤ + Redis
4. **> 20ä¸‡è®¾å¤‡**: 10+èŠ‚ç‚¹ + å¾®æœåŠ¡åŒ–

### 8.2 å…³é”®æŠ€æœ¯é€‰å‹

| ç»„ä»¶ | æ¨èæ–¹æ¡ˆ | å¤‡é€‰æ–¹æ¡ˆ |
|------|---------|---------|
| **è´Ÿè½½å‡è¡¡** | Nginx + Keepalived | HAProxy, LVS |
| **æœåŠ¡å‘ç°** | Consul | etcd, Nacos |
| **åˆ†å¸ƒå¼ EventBus** | Redis Pub/Sub | Kafka, NATS |
| **æ•°æ®åº“** | PostgreSQL ä¸»ä» | MySQL, TiDB |
| **ç¼“å­˜** | Redis Cluster | Memcached |
| **ç¼–æ’** | Kubernetes | Docker Swarm |
| **ç›‘æ§** | Prometheus + Grafana | Zabbix, Datadog |
| **æ—¥å¿—** | ELK Stack | Loki, Splunk |

### 8.3 ç›‘æ§æŒ‡æ ‡

**å…³é”®æŒ‡æ ‡**:
- èŠ‚ç‚¹å¥åº·çŠ¶æ€
- è¯·æ±‚åˆ†å¸ƒï¼ˆæ¯èŠ‚ç‚¹ QPSï¼‰
- Redis å»¶è¿Ÿå’Œå‘½ä¸­ç‡
- æ•°æ®åº“ä¸»ä»å»¶è¿Ÿ
- MQTT è¿æ¥åˆ†å¸ƒ
- æ¶ˆæ¯é˜Ÿåˆ—ç§¯å‹
- èµ„æºä½¿ç”¨ç‡ï¼ˆCPUã€å†…å­˜ã€ç£ç›˜ï¼‰

**å‘Šè­¦è§„åˆ™**:
- èŠ‚ç‚¹å®•æœº
- ä¸»ä»å»¶è¿Ÿ > 5s
- Redis è¿æ¥å¤±è´¥
- æ¶ˆæ¯ç§¯å‹ > 10000
- CPU ä½¿ç”¨ç‡ > 80%
- å†…å­˜ä½¿ç”¨ç‡ > 85%

### 8.4 å®¹ç¾æ–¹æ¡ˆ

#### A. åŒåŸåŒæ´»

```
æœºæˆ¿ A                    æœºæˆ¿ B
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ FLUX-1  â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚ FLUX-2  â”‚
â”‚ FLUX-3  â”‚   ä¸“çº¿ 10Gbps â”‚ FLUX-4  â”‚
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜              â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
     â”‚                        â”‚
â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”              â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”
â”‚ Redis-A â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚ Redis-B â”‚
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜   åŒæ­¥å¤åˆ¶    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
     â”‚                        â”‚
â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”              â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”
â”‚  PG-A   â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚  PG-B   â”‚
â”‚ (ä¸»)    â”‚   æµå¤åˆ¶      â”‚ (ä»)    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### B. å¼‚åœ°å¤šæ´»

```
åŒ—äº¬                ä¸Šæµ·                æ·±åœ³
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ FLUX-BJ â”‚â—„â”€â”€â”€â”€â”€â”€â–ºâ”‚ FLUX-SH â”‚â—„â”€â”€â”€â”€â”€â”€â–ºâ”‚ FLUX-SZ â”‚
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
     â”‚                  â”‚                  â”‚
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â”‚
                 â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”
                 â”‚ Redis Clusterâ”‚
                 â”‚ (å…¨çƒåˆ†å¸ƒ)   â”‚
                 â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
                        â”‚
                 â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”
                 â”‚  TiDB/CockDB â”‚
                 â”‚ (åˆ†å¸ƒå¼æ•°æ®åº“)â”‚
                 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 8.5 å®‰å…¨åŠ å›º

**é›†ç¾¤ç¯å¢ƒå®‰å…¨æ¸…å•**:

- [ ] èŠ‚ç‚¹é—´é€šä¿¡åŠ å¯†ï¼ˆTLSï¼‰
- [ ] Redis å¯†ç è®¤è¯
- [ ] PostgreSQL SSL è¿æ¥
- [ ] ç½‘ç»œéš”ç¦»ï¼ˆVPCï¼‰
- [ ] é˜²ç«å¢™è§„åˆ™
- [ ] è®¿é—®æ§åˆ¶ï¼ˆRBACï¼‰
- [ ] å®¡è®¡æ—¥å¿—
- [ ] å®šæœŸå®‰å…¨æ‰«æ

---

## 9. æ€»ç»“

### 9.1 ä¼˜åŠ¿

âœ… **é«˜å¯ç”¨**: 99.99% å¯ç”¨æ€§  
âœ… **é«˜æ€§èƒ½**: 10x+ ååé‡æå‡  
âœ… **å¯æ‰©å±•**: æ”¯æŒç™¾ä¸‡çº§è®¾å¤‡  
âœ… **å®¹ç¾**: è·¨åœ°åŸŸéƒ¨ç½²  
âœ… **æˆæœ¬ä¼˜åŒ–**: æŒ‰éœ€æ‰©ç¼©å®¹  

### 9.2 æŒ‘æˆ˜

âš ï¸ **å¤æ‚åº¦**: è¿ç»´éš¾åº¦å¢åŠ   
âš ï¸ **ä¸€è‡´æ€§**: åˆ†å¸ƒå¼äº‹åŠ¡å¤„ç†  
âš ï¸ **å»¶è¿Ÿ**: è·¨èŠ‚ç‚¹é€šä¿¡å¼€é”€  
âš ï¸ **æˆæœ¬**: åŸºç¡€è®¾æ–½æŠ•å…¥  
âš ï¸ **è°ƒè¯•**: åˆ†å¸ƒå¼é—®é¢˜å®šä½å›°éš¾  

### 9.3 å†³ç­–çŸ©é˜µ

| è®¾å¤‡è§„æ¨¡ | æ¨èæ¶æ„ | é¢„ä¼°æˆæœ¬ | å®æ–½å‘¨æœŸ |
|---------|---------|---------|---------|
| **< 1ä¸‡** | å•èŠ‚ç‚¹ | $200/æœˆ | å·²å®Œæˆ |
| **1-5ä¸‡** | ä¸»ä»å¤åˆ¶ | $800/æœˆ | 2-3 å‘¨ |
| **5-20ä¸‡** | 3èŠ‚ç‚¹é›†ç¾¤ | $1,500/æœˆ | 6-8 å‘¨ |
| **> 20ä¸‡** | å¾®æœåŠ¡åŒ– | $5,000/æœˆ | 3-6 æœˆ |

---

**æ–‡æ¡£ç‰ˆæœ¬**: 1.0  
**æœ€åæ›´æ–°**: 2026-02-11  
**çŠ¶æ€**: æ–¹æ¡ˆè®¾è®¡é˜¶æ®µï¼ˆæœªå®æ–½ï¼‰
